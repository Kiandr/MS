#include <iostream>
using namespace std;

/* 
To get the lowdown on recursion and recursive functions, please see C++ Recursion Example 1 (Understanding the Basics)To get the lowdown on recursion and recursive functions, please see C++ Recursion Example 1 (Understanding the Basics)

Now let's look at an example where recursion doesn't work quite as well as standard iteration. 
Solving Prime numbers is a prime example, as the recursive function tends to be more complicated and 
slower in comparison to its iterative counterpart. A recursive prime number solver also only works for 
smaller numbers, as we are likely to run into a stack-overflow error for larger numbers (such as 5000.) We run 
into this error because the computer runs out of stack space before we can finish solving the problem. 
 
To understand this, we must first understand how computers process function calls in general. When a function is called, the CPU 
has to save all the data in its registers someplace. It must do this because the function that is being called is going 
to need those registers for itself. CPUs generally have a tiny number of registers, so space is very restricted. The place 
where this data is stored is called the stack. When a function completes the CPU pops the data from the stack and stores it back into 
the registers again. 
 
But this stack space is limited. If we perform too many nested function calls we will run out of space. When this happens we 
get a Stack Overflow Error. This is one of the negatives of using recursion. Recursive functions may also be slower than traditional loops. Storing and popping data onto the stack 
takes some time. 
 
So anyway, back to the example: 
    A prime number is divisible evenly only by itself and 1. 
    The recursive function takes a num and a divisor. We check to see if num is prime by dividing it by the divisor. 
    If it evenly divides then the number is not prime, and we return false. 
    If the number does not evenly divide then we reduce the divisor by 1 and recurse a level deeper 
    If we get to the point where divisor = 1 then we must be a prime number, as no other number evenly divided into num. 
*/ 
bool isPrimeRecursive(int num, int divisor) 
{ 
    cout << "Checking to see if " << num << " is divisible by " << divisor << endl; 
    if(divisor == 1) 
    { 
        cout << num << " must be a prime number, as we got to the case where divisor = 1"; 
        return true; 
    } 
 
    /* 
    You may not have encountered the % (modulus) before. This operator gives us the 
    remainder of a division. For example 10 % 3 returns 1, because 3 divides into 10 three times and has 
    a remainder of 1. A remainder of 0 means that we were able to evenly divide two numbers (such as 4 / 2.) 
    Since a prime number can only be divisible by itself and 1, we must return false if the result of the modulus is 0, as that 
    means we found another number we can divide evenly by. 
    */ 
    if(num % divisor == 0)  
    { 
        cout << num << " is evenly divisble by " << divisor << " thus it must not be a prime number" << endl; 
        return false; 
    } 
    else 
    { 
        cout << num << " is not evenly divisible by " << divisor << ", recurse deeper" << endl;
        return isPrimeRecursive(num, divisor - 1); 
    } 
} 
 
/* 
    It sometimes helps to have a function that 'primes the pump' for recursion. 
    This function here allows the user to just pass in num and not worry about the divisor param. 
*/ 
bool isPrime(int num) 
{ 
    cout << "Checking to see if " << num << " is prime" << endl;
    
    //1 is not a prime number. 
    if(num <= 1) 
    {
        cout << num << " is not prime" << endl;
        return false; 
    }
 
    return isPrimeRecursive(num, num - 1); 
}

int main()
{
  isPrime(2);
  cout << endl << endl;
  isPrime(6);
  cout << endl << endl;
  isPrime(11);
  return 0;
}