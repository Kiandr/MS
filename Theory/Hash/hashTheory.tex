\documentclass{IEEEtran}
\usepackage[utf8]{inputenc}

\title{SPI Atmel Application Note}

\author{Kian Davoudi EIT, MASC, PhD Candidate}
\date{January 2016}
\usepackage{multirow}
\usepackage{verbatim}
\usepackage{listings}
\usepackage{enumerate}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{paralist}
\usepackage{natbib}
\usepackage{graphicx}
\usepackage[inline]{enumitem}
\usepackage[colorlinks = true,
            linkcolor = blue,
            urlcolor  = blue,
            citecolor = blue,
            anchorcolor = blue]{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{amsmath}
\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\begin{document}
\maketitle

\begin{abstract}
SPI protocol is being used to communicate between Slave and Master architecture. Today, at the end of the communication protocols we can find the inter-integrated circuit and the serial peripheral interface. Both protocols are well suited for communication between integrated circuits for slow communication with on-board peripherals. At the root of these protocols we can find two major companies, Motorola SPI and Philips I2C and two different histories about why these two were created.  
\end{abstract}

\section{History}
oday, at the low end of the communication protocols we  nd the inter-integrated circuit (I2C) and the serial peripheral interface (SPI) protocols. Both protocols are well suited for communications between integrated cir- cuits for slow communication with on-board peripherals. The two protocols coexist in modern digital electronics systems, and they probably will continue to compete in the future, as both I2C and SPI are actually quite complementary for this kind of communication \cite{leens2009introduction}.\\
At the roots of these popular protocols, we  nd two major companies—Motorola for SPI and Philips for I2C—and two different histories about why, when, and how the protocols were created. The SPI was introduced with the  rst micron- troller that derived from the same architecture as the popular Motorola 68000 microprocessor announced in 1979. For those who do not remember, the 16-bit 68000 microprocessor was at that time indisputably the best microprocessor on the market and was used in the Apple Macintosh computer in 1984. The microcontroller series was the 68xx. One of the  rst micro- controllers with an SPI bus was the M68HC03. The Motorola M68HC11 microcontroller, still available today, is also derived from this architecture. SPI was de ned as the external micro- controller bus and was used to connect the microcontroller peripherals with four wires. Unlike I2C, it is hard to  nd a formal separate “speci cation” of the SPI bus—for a detailed “of cial” description, one has to read the microcontroller data sheets and associated application notes \cite{leens2009introduction}.
The I2C bus was developed in 1982; its original purpose was to provide an easy way to connect a CPU to peripheral chips in a television set. Peripheral devices in embedded systems are often connected to the microcontroller as memory-mapped I/O devices. One common way to do this is connecting the peripher- als to the microcontroller parallel address and data busses. This results in lots of wiring on the printed circuit board (PCB) and additional “glue logic” to decode the address bus on which all the peripherals are connected. In order to spare microcontroller pins, additional logic, and to make the PCBs simpler (in other words, to lower the costs), Philips labs in Eindhoven, The Neth- erlands, invented the “inter-integrated circuit,” IIC or I2C proto- col that only requires two wires for connecting all the peripher- als to a microcontroller. The original speci cation de ned a bus speed of 100 kb/s. The speci cation was reviewed several times, notably introducing the 400 kb/s speed in 1995 and, since 1998, 3.4 Mb/s for even faster peripherals. As of October 1, 2006, no li- censing fees are required to implement the I2C protocol, making of cial a type of “fair open policy” that Philips Semiconductor has always demonstrated with I2C. Strictly speaking, fees are still required to “of cially” allocate slave I2C addresses.NXP (formerly Philips Semiconductor) and Freescale (formerly the semiconductor branch of Motorola) are today in charge for the I2C and SPI “of cial” speci cations, although the protocols have become so popular that we could wonder if they are not rather de facto public protocols. Let’s review each of these protocols. \ref{fig:SPI protocol}

\begin{figure}[h!]
\centering
\includegraphics[scale=.4]{./figs/Fig1.png}
\caption{ A network of PPG sensors for detection of blood perfusion within muscle. }
\label{fig:SPI protocol}
\end{figure}

\section{SPI Communication Protocol}
SPI is quite straightforward, it defines features any digital electronic engineer would think of if it were necessary to quickly define a way to communicate between two digital devices. SPI is a protocol on four signal lines . Clock signal(SCLK)sent from the bus master to all slaves; all the SPI signals are synchronous to this clock signal. A slave select signal (SSn) for each slave, used to select the slave the master communicates with.  A data line from the master to the slaves, named Master Out-Slave In (MOSI).  A data line from the slaves to the master, named Master In-Slave Out (MISO). SPI is a single-master communication protocol. This means that one central device initiates all the communications with the slaves. When the SPI master wishes to send data to a slave and/or request information from it, it selects a slave by pull- ing the corresponding SS line low, and it activates the clock signal at a clock frequency usable by the master and the slave. The master generates information onto the MOSI line while it samples the MISO line [\ref{fig:spiClock}]. Four communication modes are available (MODE 0, 1, 2, 3) that define as  the SCLK edge on which the MOSI line toggles. The SCLK edge on which the master samples the MISO line. The SCLK signal steady level (that is, the clock level, high or low, when the clock is not active). Each mode is formally de ned with a pair of parameters called clock polarity (CPOL) and clock phase (CPHA) [\ref{fig:SPIMasterClock}].  master/slave pair must use the same set of parameters—SCLK frequency, CPOL, and CPHA for a communication to be possible. If multiple slaves are used that are fixed in different configurations, the master will have to recon gure itself each time it needs to communicate with a different slave.

\begin{figure}[h!]
\centering
\includegraphics[scale=.2]{./figs/spiClock.png}
\caption{ This is the master clock, all the slaves are synchronized  with this master clock. }
\label{fig:SPIMasterClock}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[scale=.2]{./figs/MasterSlaveCommunication.png}
\caption{There are four different modes that SPI is master is talking to slaves.. }
\label{fig:SPICommunicationModes}
\end{figure}




\section{Hello World}
The first step in any development environment, is to set up the dev and print a hello world. To achieve this, Atemel provides a shell Visual Studio environment. This software, provides sufficient out of the box tools such as visualization tool and lots of drivers. But, it lack of providing serial terminal, which is being used to debug the solution. For this reason, \href{https://gallery.atmel.com/Products/Details/43e9ea03-72f7-4069-b0d4-9ac907cee81d}{this} link has been recommended by Atmel which points to a Serial Terminal software. 

\begin{figure}[h!]
\centering
\includegraphics[scale=.4]{./figs/changePortSpeed.png}
\caption{ Use device manager to change serial port speed rate to 115200 bit per second. }
\label{fig:Device Manager}
\end{figure}

\begin{figure}[h!]
\centering
\includegraphics[scale=.2]{./figs/VSScreen.png}
\caption{Use the integrated Serial Terminal extension on the Virtual Port to view the output of the console. }
\label{fig:Visual Studio}
\end{figure}

\section{Read Protocol in SPI interface}
The following  figure [\ref{fig:SPI protocol}] is the simplest protocol to read a byte from SPI driver. A status register read transaction would be similar to the write transaction, but now takes advantage of data returned from the slave as shown in Figure 8. After sending the read status register instruction, the slave begins transmitting data on the MISO line at a rate of one byte per eight clock cycles. The host receives the bitstream and completes the transaction by de-asserting SS#. However, in this dissertation, Atmel official website was used to build SPI drive. Please view \href{http://asf.atmel.com/docs/3.32.0/thirdparty.wireless.avr2025_mac.apps.mac.serial_if.bcn_ffd.ncp.sam4sd32c_reb233_xpro/html/sam_spi_quickstart.html} {link}. 

\begin{figure}[h!]
\centering
\includegraphics[scale=.5]{./figs/SPIReadProtocol.png}
\label{fig:Visual Studio}
\end{figure}


\section{Testing SPI Protocol}
Atmel Software Frame (ASF) is being consisted of set of headres, macros and functions that provides some idea about operation of the Ateml peripherals and MCUs. In this section, the \href {http://www.atmel.com/tools/ATOLED1-XPRO.aspx}{ OLDED1 Xplain Pro} is being used as SPI Slave kit. The following is the test mechanism that shall take place to ensure SAM4S is capable operating at Master Slave mode. 

\begin{figure}[h!]
\centering
\includegraphics[scale=.08]{./figs/MCU.png}
\caption{ Illustration of the pins}
\label{fig:MCUSchematics}
\end{figure}

\section{Programming without ASF}
\href{http://mwmw.ca/gpio.html}{This} website, had provided a reliable introduction to programming Atmel without ASF. 
\begin{figure}[h!]
\centering
\includegraphics[scale=.5]{./figs/blink.png}
\caption{ Hello world, on SAM4S. This program illustrates how to blink and LED on GPIO on pin 13 SAM4S}
\label{fig:blinkSAM4S}
\end{figure}

\subsection{EnableDisablePins}
As the author in the tutorial points out, there are macros to enable and disable the pins, refer to xx figure to outline the macros in your code. 
\section{Programming without ASF}
\href{http://mwmw.ca/gpio.html}{This} website, had provided a reliable introduction to programming Atmel without ASF. 
\begin{figure}[h!]
\centering
\includegraphics[scale=.2]{./figs/macros.png}
\caption{ Hello world, on SAM4S. This program illustrates how to blink and LED on GPIO on pin 13 SAM4S}
\label{fig:blinkSAM4S}
\end{figure}

\section{Ads1299 Firmware}
According the the manual of the TI chip there is a very spesific pre-configuration that should take place in order to enable the TI chip to operate. This process has been descvired in page 61 of the \href{http://www.compliahealth.com/products/procura-na/overview.htm}{manual}. 

\begin{figure}[h!]
\centering
\includegraphics[scale=.2]{./figs/ti.png}
\caption{ TI chip operation manual. All the following steps shall be taken place accurately in order to enable ATEML to talk to TI}
\label{fig:TIManual}
\end{figure}




\bibliographystyle{plain}
\bibliography{references}

\end{document}
